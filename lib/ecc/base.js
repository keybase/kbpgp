// Generated by IcedCoffeeScript 108.0.11
(function() {
  var BaseEccKey, SlicerBuffer, alloc_by_name, alloc_by_nbits, alloc_by_oid, iced, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;

  _ref = require('./curves'), alloc_by_nbits = _ref.alloc_by_nbits, alloc_by_oid = _ref.alloc_by_oid, alloc_by_name = _ref.alloc_by_name;

  exports.BaseEccKey = BaseEccKey = (function() {
    function BaseEccKey(_arg) {
      this.curve = _arg.curve, this.R = _arg.R;
    }

    BaseEccKey.prototype.serialize = function() {
      var oid;
      oid = this.curve.oid;
      return Buffer.concat([Buffer.from([oid.length]), oid, this.curve.point_to_mpi_buffer(this.R)]);
    };

    BaseEccKey._alloc = function(klass, raw) {
      var R, curve, err, l, len, oid, pre, pub, sb, _ref1, _ref2;
      sb = new SlicerBuffer(raw);
      pre = sb.rem();
      l = sb.read_uint8();
      oid = sb.read_buffer(l);
      _ref1 = alloc_by_oid(oid), err = _ref1[0], curve = _ref1[1];
      if (err != null) {
        throw err;
      }
      _ref2 = curve.mpi_point_from_slicer_buffer(sb), err = _ref2[0], R = _ref2[1];
      if (err != null) {
        throw err;
      }
      pub = new klass({
        curve: curve,
        R: R
      });
      pub.read_params(sb);
      len = pre - sb.rem();
      return [pub, len];
    };

    BaseEccKey.alloc = function(klass, raw) {
      var e, err, len, pub, _ref1;
      pub = len = err = null;
      try {
        _ref1 = BaseEccKey._alloc(klass, raw), pub = _ref1[0], len = _ref1[1];
      } catch (_error) {
        e = _error;
        err = e;
      }
      return [err, pub, len];
    };

    BaseEccKey.prototype.validity_check = function(cb) {
      return cb(null);
    };

    return BaseEccKey;

  })();

  exports.generate = function(_arg, cb) {
    var Pair, R, asp, curve, curve_name, err, nbits, priv, pub, ret, x, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1, _ref2;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    nbits = _arg.nbits, asp = _arg.asp, curve_name = _arg.curve_name, Pair = _arg.Pair;
    ret = null;
    if (curve_name) {
      _ref1 = alloc_by_name(curve_name), err = _ref1[0], curve = _ref1[1];
    } else {
      _ref2 = alloc_by_nbits(nbits), err = _ref2[0], curve = _ref2[1];
    }
    (function(_this) {
      return (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/kbpgp/src/ecc/base.iced",
              funcname: "generate"
            });
            curve.generate(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  x = arguments[0].x;
                  return R = arguments[0].R;
                };
              })(),
              lineno: 58
            }));
            __iced_deferrals._fulfill();
          })(function() {
            pub = new Pair.Pub({
              curve: curve,
              R: R
            });
            priv = new Pair.Priv({
              pub: pub,
              x: x
            });
            return __iced_k(ret = new Pair({
              pub: pub,
              priv: priv
            }));
          });
        } else {
          return __iced_k();
        }
      });
    })(this)((function(_this) {
      return function() {
        return cb(err, ret);
      };
    })(this));
  };

}).call(this);
